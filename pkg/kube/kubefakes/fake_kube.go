// Code generated by counterfeiter. DO NOT EDIT.
package kubefakes

import (
	"context"
	"sync"

	"github.com/weaveworks/weave-gitops/pkg/kube"
	v1 "k8s.io/api/core/v1"
	"sigs.k8s.io/controller-runtime/pkg/client"
)

type FakeKube struct {
	FetchNamespaceWithLabelStub        func(context.Context, string, string) (*v1.Namespace, error)
	fetchNamespaceWithLabelMutex       sync.RWMutex
	fetchNamespaceWithLabelArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	fetchNamespaceWithLabelReturns struct {
		result1 *v1.Namespace
		result2 error
	}
	fetchNamespaceWithLabelReturnsOnCall map[int]struct {
		result1 *v1.Namespace
		result2 error
	}
	GetClusterNameStub        func(context.Context) (string, error)
	getClusterNameMutex       sync.RWMutex
	getClusterNameArgsForCall []struct {
		arg1 context.Context
	}
	getClusterNameReturns struct {
		result1 string
		result2 error
	}
	getClusterNameReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	GetWegoConfigStub        func(context.Context, string) (*kube.WegoConfig, error)
	getWegoConfigMutex       sync.RWMutex
	getWegoConfigArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	getWegoConfigReturns struct {
		result1 *kube.WegoConfig
		result2 error
	}
	getWegoConfigReturnsOnCall map[int]struct {
		result1 *kube.WegoConfig
		result2 error
	}
	RawStub        func() client.Client
	rawMutex       sync.RWMutex
	rawArgsForCall []struct {
	}
	rawReturns struct {
		result1 client.Client
	}
	rawReturnsOnCall map[int]struct {
		result1 client.Client
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeKube) FetchNamespaceWithLabel(arg1 context.Context, arg2 string, arg3 string) (*v1.Namespace, error) {
	fake.fetchNamespaceWithLabelMutex.Lock()
	ret, specificReturn := fake.fetchNamespaceWithLabelReturnsOnCall[len(fake.fetchNamespaceWithLabelArgsForCall)]
	fake.fetchNamespaceWithLabelArgsForCall = append(fake.fetchNamespaceWithLabelArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.FetchNamespaceWithLabelStub
	fakeReturns := fake.fetchNamespaceWithLabelReturns
	fake.recordInvocation("FetchNamespaceWithLabel", []interface{}{arg1, arg2, arg3})
	fake.fetchNamespaceWithLabelMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKube) FetchNamespaceWithLabelCallCount() int {
	fake.fetchNamespaceWithLabelMutex.RLock()
	defer fake.fetchNamespaceWithLabelMutex.RUnlock()
	return len(fake.fetchNamespaceWithLabelArgsForCall)
}

func (fake *FakeKube) FetchNamespaceWithLabelCalls(stub func(context.Context, string, string) (*v1.Namespace, error)) {
	fake.fetchNamespaceWithLabelMutex.Lock()
	defer fake.fetchNamespaceWithLabelMutex.Unlock()
	fake.FetchNamespaceWithLabelStub = stub
}

func (fake *FakeKube) FetchNamespaceWithLabelArgsForCall(i int) (context.Context, string, string) {
	fake.fetchNamespaceWithLabelMutex.RLock()
	defer fake.fetchNamespaceWithLabelMutex.RUnlock()
	argsForCall := fake.fetchNamespaceWithLabelArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeKube) FetchNamespaceWithLabelReturns(result1 *v1.Namespace, result2 error) {
	fake.fetchNamespaceWithLabelMutex.Lock()
	defer fake.fetchNamespaceWithLabelMutex.Unlock()
	fake.FetchNamespaceWithLabelStub = nil
	fake.fetchNamespaceWithLabelReturns = struct {
		result1 *v1.Namespace
		result2 error
	}{result1, result2}
}

func (fake *FakeKube) FetchNamespaceWithLabelReturnsOnCall(i int, result1 *v1.Namespace, result2 error) {
	fake.fetchNamespaceWithLabelMutex.Lock()
	defer fake.fetchNamespaceWithLabelMutex.Unlock()
	fake.FetchNamespaceWithLabelStub = nil
	if fake.fetchNamespaceWithLabelReturnsOnCall == nil {
		fake.fetchNamespaceWithLabelReturnsOnCall = make(map[int]struct {
			result1 *v1.Namespace
			result2 error
		})
	}
	fake.fetchNamespaceWithLabelReturnsOnCall[i] = struct {
		result1 *v1.Namespace
		result2 error
	}{result1, result2}
}

func (fake *FakeKube) GetClusterName(arg1 context.Context) (string, error) {
	fake.getClusterNameMutex.Lock()
	ret, specificReturn := fake.getClusterNameReturnsOnCall[len(fake.getClusterNameArgsForCall)]
	fake.getClusterNameArgsForCall = append(fake.getClusterNameArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.GetClusterNameStub
	fakeReturns := fake.getClusterNameReturns
	fake.recordInvocation("GetClusterName", []interface{}{arg1})
	fake.getClusterNameMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKube) GetClusterNameCallCount() int {
	fake.getClusterNameMutex.RLock()
	defer fake.getClusterNameMutex.RUnlock()
	return len(fake.getClusterNameArgsForCall)
}

func (fake *FakeKube) GetClusterNameCalls(stub func(context.Context) (string, error)) {
	fake.getClusterNameMutex.Lock()
	defer fake.getClusterNameMutex.Unlock()
	fake.GetClusterNameStub = stub
}

func (fake *FakeKube) GetClusterNameArgsForCall(i int) context.Context {
	fake.getClusterNameMutex.RLock()
	defer fake.getClusterNameMutex.RUnlock()
	argsForCall := fake.getClusterNameArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeKube) GetClusterNameReturns(result1 string, result2 error) {
	fake.getClusterNameMutex.Lock()
	defer fake.getClusterNameMutex.Unlock()
	fake.GetClusterNameStub = nil
	fake.getClusterNameReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeKube) GetClusterNameReturnsOnCall(i int, result1 string, result2 error) {
	fake.getClusterNameMutex.Lock()
	defer fake.getClusterNameMutex.Unlock()
	fake.GetClusterNameStub = nil
	if fake.getClusterNameReturnsOnCall == nil {
		fake.getClusterNameReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.getClusterNameReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeKube) GetWegoConfig(arg1 context.Context, arg2 string) (*kube.WegoConfig, error) {
	fake.getWegoConfigMutex.Lock()
	ret, specificReturn := fake.getWegoConfigReturnsOnCall[len(fake.getWegoConfigArgsForCall)]
	fake.getWegoConfigArgsForCall = append(fake.getWegoConfigArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.GetWegoConfigStub
	fakeReturns := fake.getWegoConfigReturns
	fake.recordInvocation("GetWegoConfig", []interface{}{arg1, arg2})
	fake.getWegoConfigMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeKube) GetWegoConfigCallCount() int {
	fake.getWegoConfigMutex.RLock()
	defer fake.getWegoConfigMutex.RUnlock()
	return len(fake.getWegoConfigArgsForCall)
}

func (fake *FakeKube) GetWegoConfigCalls(stub func(context.Context, string) (*kube.WegoConfig, error)) {
	fake.getWegoConfigMutex.Lock()
	defer fake.getWegoConfigMutex.Unlock()
	fake.GetWegoConfigStub = stub
}

func (fake *FakeKube) GetWegoConfigArgsForCall(i int) (context.Context, string) {
	fake.getWegoConfigMutex.RLock()
	defer fake.getWegoConfigMutex.RUnlock()
	argsForCall := fake.getWegoConfigArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeKube) GetWegoConfigReturns(result1 *kube.WegoConfig, result2 error) {
	fake.getWegoConfigMutex.Lock()
	defer fake.getWegoConfigMutex.Unlock()
	fake.GetWegoConfigStub = nil
	fake.getWegoConfigReturns = struct {
		result1 *kube.WegoConfig
		result2 error
	}{result1, result2}
}

func (fake *FakeKube) GetWegoConfigReturnsOnCall(i int, result1 *kube.WegoConfig, result2 error) {
	fake.getWegoConfigMutex.Lock()
	defer fake.getWegoConfigMutex.Unlock()
	fake.GetWegoConfigStub = nil
	if fake.getWegoConfigReturnsOnCall == nil {
		fake.getWegoConfigReturnsOnCall = make(map[int]struct {
			result1 *kube.WegoConfig
			result2 error
		})
	}
	fake.getWegoConfigReturnsOnCall[i] = struct {
		result1 *kube.WegoConfig
		result2 error
	}{result1, result2}
}

func (fake *FakeKube) Raw() client.Client {
	fake.rawMutex.Lock()
	ret, specificReturn := fake.rawReturnsOnCall[len(fake.rawArgsForCall)]
	fake.rawArgsForCall = append(fake.rawArgsForCall, struct {
	}{})
	stub := fake.RawStub
	fakeReturns := fake.rawReturns
	fake.recordInvocation("Raw", []interface{}{})
	fake.rawMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeKube) RawCallCount() int {
	fake.rawMutex.RLock()
	defer fake.rawMutex.RUnlock()
	return len(fake.rawArgsForCall)
}

func (fake *FakeKube) RawCalls(stub func() client.Client) {
	fake.rawMutex.Lock()
	defer fake.rawMutex.Unlock()
	fake.RawStub = stub
}

func (fake *FakeKube) RawReturns(result1 client.Client) {
	fake.rawMutex.Lock()
	defer fake.rawMutex.Unlock()
	fake.RawStub = nil
	fake.rawReturns = struct {
		result1 client.Client
	}{result1}
}

func (fake *FakeKube) RawReturnsOnCall(i int, result1 client.Client) {
	fake.rawMutex.Lock()
	defer fake.rawMutex.Unlock()
	fake.RawStub = nil
	if fake.rawReturnsOnCall == nil {
		fake.rawReturnsOnCall = make(map[int]struct {
			result1 client.Client
		})
	}
	fake.rawReturnsOnCall[i] = struct {
		result1 client.Client
	}{result1}
}

func (fake *FakeKube) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.fetchNamespaceWithLabelMutex.RLock()
	defer fake.fetchNamespaceWithLabelMutex.RUnlock()
	fake.getClusterNameMutex.RLock()
	defer fake.getClusterNameMutex.RUnlock()
	fake.getWegoConfigMutex.RLock()
	defer fake.getWegoConfigMutex.RUnlock()
	fake.rawMutex.RLock()
	defer fake.rawMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeKube) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ kube.Kube = new(FakeKube)
